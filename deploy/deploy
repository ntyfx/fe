#!/usr/bin/env bash

#
# deploy(1) - Minimalistic shell script to deploy Git repositories.
# Released under the MIT License.
#
# https://github.com/visionmedia/deploy
#

VERSION="0.6.0"
CONFIG=./deploy.conf
LOG=/tmp/fe-deploy.log
TEST=1
FORCE=0
REF=
ENV=

#
# Read PIPED JSON
#
read conf

#
# Output usage information.
#

usage() {
    cat <<-EOF

    Usage: deploy [options] <env> [command]

    Options:

        -C, --chdir <path>   change the working directory to <path>
        -c, --config <path>  set config path. defaults to ./deploy.conf
        -T, --no-tests       ignore test hook
        -V, --version        output program version
        -h, --help           output help information
        -f, --force          skip local change checking

    Commands:

        setup                run remote setup commands
        revert [n]           revert to [n]th last deployment or 1
        config [key]         output config file or [key]
        curr[ent]            output current release commit
        prev[ious]           output previous release commit
        exec|run <cmd>       execute the given <cmd>
        list                 list previous deploy commits
        ref [ref]            deploy [ref]

EOF
}

#
# Log <msg>.
#

log() {
    echo -e "[\033[02m`date '+%H:%M:%S'`\033[0m] $@"
}

logRed() {
    echo -e "[\033[02m`date '+%H:%M:%S'`\033[0m] \033[31m $@ \033[0m"
}

logGreen() {
    echo -e "[\033[02m`date '+%H:%M:%S'`\033[0m] \033[32m $@ \033[0m"
}

logYellow() {
    echo -e "[\033[02m`date '+%H:%M:%S'`\033[0m] \033[33m $@ \033[0m"
}

#
# Abort with <msg>
#

abort() {
    logRed "$@" 1>&2
    logRed "===================== 发布失败 [`config_get host`] ====================="
    logRed
    logRed
    exit 1
}


#
# Get config value by <key>.
#

config_get() {
    local key=$1
    echo $(expr "$conf" : '.*"'$key'":"\([^"]*\)"')
}

#
# Output version.
#

version() {
    echo $VERSION
}

#
# Return the ssh command to run.
#

ssh_command() {
    local url="`config_get user`@`config_get host`"
    local unexpanded_key="`config_get key`"
    local key="${unexpanded_key/#\~/$HOME}"
    local forward_agent="`config_get forward-agent`"
    local port="`config_get port`"
    local needs_tty="`config_get needs_tty`"
    local ssh_options="`config_get ssh_options`"

    test -n "$forward_agent" && local agent="-A"
    test -n "$key" && local identity="-i $key"
    test -n "$port" && local port="-p $port"
    test -n "$needs_tty" && local tty="-t"
    test -n "ssh_options" && local ssh_opts="$ssh_options"
    echo "ssh $ssh_opts $tty $agent $port $identity $url"
}

#
# Run the given remote <cmd>.
#

runRemote() {
    local shell="`ssh_command`"
    echo $shell "\"$@\"" >> $LOG
    $shell $@
}

#
# Run the given local <cmd>.
#

runLocal() {
    echo "\"$@\"" >> $LOG
    /usr/bin/env bash -c "$*"
}

#
# Run the given <cmd> either locally or remotely
#

run() {
    local host="`config_get host`"
    if [[ $host == localhost ]]
    then
        runLocal $@
    else
        runRemote $@
    fi
}

#
# Output config or [key].
#

config() {
    echo $(expr "$conf" : '.*"$key":"\([^"]*\)"')
}

#
# Execute hook <name> relative to the path configured.
#

hook() {
    test -n "$1" || abort hook name required
    local hook=$1
    local path=`config_get path`
    local cmd=`config_get $hook`
    if test -n "$cmd"; then
        log "executing $hook \`$cmd\`"
        run "cd $path/current; SHARED=\"$path/shared\" $cmd 2>&1 | tee -a $LOG; exit \${PIPESTATUS[0]}"
        test $? -eq 0
    else
        log hook $hook
    fi
}

deploy() {
    local ref=$1
    local path=`config_get path`

    if test -z $path; then
        abort "未提供远程nginx根目录"
    fi

    logYellow "===================== 开始发布 [`config_get host`] ====================="

    if [ `config_get type` == 'git' ]; then
        deployGit $ref
    elif [ `config_get type` == 'npm' ]; then
        deployNpm $ref
    fi
}

deployNpm() {
    local ref=$1
    local pdl=`config_get pre-deploy-local`
    local path=`config_get path`

    logYellow `config_get name`

    # PR #50
    log executing pre-deploy-local
    local timestamp=`date '+%Y%m%d%H%M%S'`
    local version="v`config_get version`"
    local pathName="fe-`config_get group`-`config_get name`-$version"
    local fileName="$pathName-$timestamp.tar.gz"
    local localPath="/tmp/$pathName"
    local localFileName="/tmp/$fileName"
    local localModules="/tmp/node_modules/`config_get name`"
    local remoteTmpPath="/tmp/.fe"
    local remoteBasePath="`config_get path`/`config_get group`/`config_get name`"
    local remotePath="$remoteBasePath/$version"
    local remoteFileName="$remoteTmpPath/$fileName"
    local major="v`config_get major`"
    local minor="v`config_get major`.`config_get minor`"

    cd /tmp
    log "npm install `config_get name`@`config_get version`"
    npm install `config_get name`@`config_get version` --registry=`config_get registry` > /dev/null
    test $? -eq 0 || abort "下载包失败"

    log "mv $localModules $localPath"
    rm -rf $localPath
    mv $localModules $localPath
    test $? -eq 0 || abort "移动文件失败"
    cd $localPath
    log "打包文件 $localFileName"
    tar zcf $localFileName --exclude package.json --exclude node_modules -C $localPath *
    test $? -eq 0 || abort "打包文件失败 $file"

    log "创建远程临时目录 $remoteTmpPath"
    run "mkdir -p $remoteTmpPath"
    log "创建远程发版目录 $remotePath"
    run "mkdir -p $remotePath"
    test $? -eq 0 || abort "远程创建目录失败 $remotePath"
    
    log "上传文件..."
    cat $localFileName | run "cat > ${remoteFileName}"
    test $? -eq 0 || abort "上传文件失败 $localFileName"

    log "解压文件到 $remotePath"
    run "tar zxf ${remoteFileName} -C $remotePath > /dev/null"
    test $? -eq 0 || abort "解压文件失败 $remoteFileName"

    log "创建软链 $version -> latest"
    run "ln -sfn $remotePath $remoteBasePath/latest"

    log "创建软链 $version -> $major"
    run "ln -sfn $remotePath $remoteBasePath/$major"
    
    log "创建软链 $version -> $minor"
    run "ln -sfn $remotePath $remoteBasePath/$minor"

    log "清理本地临时文件 $localFileName"
    rm $localFileName
    
    log "清理远程临时文件 $remoteFileName"
    run "cd ${remoteTmpPath} && rm $fileName"

    hook post-deploy || abort post-deploy hook failed

    logGreen "===================== 发布完成 [`config_get host`] ====================="
}

#
# Deploy [ref].
#
deployGit() {
    local ref=$1
    local pdl=`config_get pre-deploy-local`
    local path=`config_get path`

    check_for_local_changes

    logYellow "Git分支 ${ref}"

    # PR #50
    log executing pre-deploy-local
    local timestamp=`date '+%Y%m%d%H%M%S'`
    local version="v`config_get version`"
    local pathName="fe-`config_get group`-`config_get name`"
    local fileName="$pathName-$version-$timestamp.tar.gz"
    local localPath="/tmp/$pathName"
    local localFileName="/tmp/$fileName"
    local remoteTmpPath="/tmp/.fe"
    local remoteBasePath="`config_get path`/`config_get group`/`config_get name`"
    local remotePath="$remoteBasePath/$version"
    local remoteFileName="$remoteTmpPath/$fileName"
    local major="v`config_get major`"
    local minor="v`config_get major`.`config_get minor`"

    runLocal $pdl

    hook pre-deploy || abort pre-deploy hook failed

    # clone source
    if test -d $localPath; then
        log "使用本地目录 $localPath"
    else
        log "下载 git 仓库 `config_get repo`"
        git clone --quiet "`config_get repo`" $localPath
    fi

    test $? -eq 0 || abort "clone `config_get repo` 失败"
    log "git 切换分支 $ref"
    cd $localPath && git fetch --quiet --all --tags && git reset --quiet --hard $ref
    test $? -eq 0 || abort "切换分支 $ref 失败"
    
    log "打包文件 $localFileName"
    tar zcf $localFileName --exclude package.json --exclude node_modules -C $localPath *
    test $? -eq 0 || abort "打包文件失败 $file"

    log "创建远程临时目录 $remoteTmpPath"
    run "mkdir -p $remoteTmpPath"
    log "创建远程发版目录 $remotePath"
    run "mkdir -p $remotePath"
    test $? -eq 0 || abort "远程创建目录失败 $remotePath"
    
    log "上传文件..."
    cat $localFileName | run "cat > ${remoteFileName}"
    test $? -eq 0 || abort "上传文件失败 $localFileName"

    log "解压文件到 $remotePath"
    run "tar zxf ${remoteFileName} -C $remotePath > /dev/null"
    test $? -eq 0 || abort "解压文件失败 $remoteFileName"

    cd $localPath
    lastVersion=$(git for-each-ref refs/tags --sort=-*authordate --format='%(refname)' --count=1 | cut -d '/' -f 3)
    if [ $lastVersion == $version ]; then
        log "创建软链 $version -> latest"
        run "ln -sfn $remotePath $remoteBasePath/latest"
    fi

    log "创建软链 $version -> $major"
    run "ln -sfn $remotePath $remoteBasePath/$major"
    
    log "创建软链 $version -> $minor"
    run "ln -sfn $remotePath $remoteBasePath/$minor"

    log "清理本地临时文件 $localFileName"
    rm $localFileName
    
    log "清理远程临时文件 $remoteFileName"
    run "cd ${remoteTmpPath} && rm $fileName"

    hook post-deploy || abort post-deploy hook failed

    logGreen "===================== 发布完成 [`config_get host`] ====================="
}

#
# Get current commit.
#

current_commit() {
    local path=`config_get path`
    run "cd $path/source && \
        git rev-parse --short HEAD"
}

#
# Get <n>th deploy commit.
#

nth_deploy_commit() {
    local n=$1
    local path=`config_get path`
    run "cat $path/.deploys | tail -n $n | head -n 1 | cut -d ' ' -f 1"
}

#
# List deploys.
#

list_deploys() {
    local path=`config_get path`
    run "tac $path/.deploys | awk '{printf \"%d\t%s\n\", NR-1, \$0}'"
}

#
# Revert to the <n>th last deployment, ignoring tests.
#

quickly_revert_to() {
    local n=$1
    log "quickly reverting $n deploy(s)"
    local commit=`nth_deploy_commit $((n + 1))`
    TEST=0 deploy "$commit"
}

#
# Revert to the <n>th last deployment.
#

revert_to() {
    local n=$1
    log "reverting $n deploy(s)"
    local commit=`nth_deploy_commit $((n + 1))`
    deploy "$commit"
}

#
# Ensure all changes are committed and pushed before deploying.
#

check_for_local_changes() {
    local path=`config_get path`

    if [ $FORCE -eq 1 ]
    then
        return
    fi
    git --no-pager diff --exit-code --quiet          || abort "发布之前提交或暂存本地的修改"
    git --no-pager diff --exit-code --quiet --cached || abort "发布之前提交代码"
    [ -z "`git rev-list @{upstream}.. -n 1`" ]       || abort "发布之前push代码"
}

# parse argv
while test $# -ne 0; do
    arg=$1; shift
    case $arg in
        -h|--help) usage; exit ;;
        -V|--version) version; exit ;;
        -C|--chdir) log cd $1; cd $1; shift ;;
        -T|--no-tests) TEST=0 ;;
        -F|--force) FORCE=1 ;;
        run|exec)  run "cd `config_get path`/current && $@"; exit ;;
        console)  console; exit ;;
        curr|current)  current_commit; exit ;;
        prev|previous)  nth_deploy_commit 2; exit ;;
        revert)  revert_to ${1-1}; exit ;;
        setup)  setup $@; exit ;;
        list)  list_deploys; exit ;;
        config) config $@; exit ;;
        ref) REF=$1 ;;
    esac
done

# deploy
deploy "${REF:-`config_get ref`}"